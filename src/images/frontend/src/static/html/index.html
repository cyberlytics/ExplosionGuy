<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8" />
    <title>Explosion Guy</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <script src="./js/socket.io.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            background: #1a1a1a;
        }
    </style>
</head>
<body>
<script type="text/javascript">


    class Load extends Phaser.Scene {
        constructor() {
            super('Loading');
        }
        preload ()
        {

            var progressBar = this.add.graphics();
            var progressBox = this.add.graphics();
            progressBox.fillStyle(0x222222, 0.8);
            progressBox.fillRect(240, 270, 320, 50);

            var width = this.cameras.main.width;
            var height = this.cameras.main.height;
            var loadingText = this.make.text({
                x: width / 2,
                y: height / 2 - 50,
                text: 'Loading...',
                style: {
                    font: '20px monospace',
                    fill: '#ffffff'
                }
            });
            loadingText.setOrigin(0.5, 0.5);

            var percentText = this.make.text({
                x: width / 2,
                y: height / 2 - 5,
                text: '0%',
                style: {
                    font: '18px monospace',
                    fill: '#ffffff'
                }
            });
            percentText.setOrigin(0.5, 0.5);

            var assetText = this.make.text({
                x: width / 2,
                y: height / 2 + 50,
                text: '',
                style: {
                    font: '18px monospace',
                    fill: '#ffffff'
                }
            });
            assetText.setOrigin(0.5, 0.5);

            this.load.on('progress', function (value) {
                percentText.setText(parseInt(value * 100) + '%');
                progressBar.clear();
                progressBar.fillStyle(0xffffff, 1);
                progressBar.fillRect(250, 280, 300 * value, 30);
            });

            this.load.on('fileprogress', function (file) {
                assetText.setText('Loading asset: ' + file.key);
            });

            this.load.image("tiles", "assets/tilemaps/tileBild.png");
            this.load.spritesheet("player-movement", "assets/player_movement.png",{frameWidth: 32,frameHeight: 32})
            this.load.image("player", "assets/player.png")
            //Daten aus erstellter JSON Tilemap beziehen
            this.load.tilemapTiledJSON("map","assets/tilemaps/explosionGuy.tmj");
            this.load.spritesheet("bomb", "assets/bomb.png",{frameWidth: 32,frameHeight: 32});
            this.load.spritesheet("explosion", "assets/explosion.png",{frameWidth: 32,frameHeight: 32});

            this.load.on('complete', function () {
                progressBar.destroy();
                progressBox.destroy();
                loadingText.destroy();
                percentText.destroy();
                assetText.destroy();
            });


        }
        create() {
            //Animationen
            //Bombe & Explosions Animation
            this.anims.create({key: 'bomb-idle',
                frames: this.anims.generateFrameNumbers('bomb', {start: 0,end: 1}),
                repeat: -1,
                frameRate: 2
            });

            this.anims.create({key: 'boom',
                frames: this.anims.generateFrameNumbers('explosion', {start: 0,end: 7}),
                repeat: 0,
                frameRate: 5
            });

            this.anims.create({key: 'go-left',
                frames: this.anims.generateFrameNumbers('player-movement', {start: 1,end: 2}),
                repeat: -1,
                frameRate: 5
            });
            this.anims.create({key: 'go-right',
                frames: this.anims.generateFrameNumbers('player-movement', {start: 3,end: 4}),
                repeat: -1,
                frameRate: 5
            });
            this.anims.create({key: 'go-down',
                frames: this.anims.generateFrameNumbers('player-movement', {start: 5,end: 6}),
                repeat: -1,
                frameRate: 5
            });
            this.anims.create({key: 'go-up',
                frames: this.anims.generateFrameNumbers('player-movement', {start: 7,end: 8}),
                repeat: -1,
                frameRate: 5
            });

            this.scene.start('MainLevelScene');
        }
    }

    function checkInstance(direct, breakable, wall) {
        const DIRECTIONS = [
            {name: 'left', axis: 'x', position: -32},
            {name: 'right', axis: 'x',position: 32},
            {name: 'up', axis: 'y', position: -32},
            {name: 'down', axis: 'y', position: 32}
        ];
        let direkt = DIRECTIONS.find(direction => direction.name === direct);

        let result = {
            name: direkt.name,
            position: direkt.position,
            obstracle : breakable,
            wand: wall};

        return result;
    }



    class MainLevel extends Phaser.Scene {

        constructor() {
            super('MainLevelScene');
        }
        create ()
        {
            // Map JSON von von Tiled laden
            const map = this.make.tilemap({key: "map", tileWidth:32, tileHeight:32});
            const tileset = map.addTilesetImage("tileBild", "tiles");

            // map Layer erstellen aus Tile-Layerdaten
            this.walls = map.createLayer("hintergrund", tileset, 0, 0);
            this.obstracles = map.createLayer("interaktiv", tileset, 0, 0);
            // Kollisions-Eigenschaft sowie Destroy-Eigenschaft aus Layer beziehen
            this.walls.setCollisionByProperty({collide:true});
            this.obstracles.setCollisionByProperty({collide:true});

            this.player = new Player(this, 48, 48);
            this.cursors = this.input.keyboard.createCursorKeys();
        }

        update ()
        {

            if (this.input.keyboard.checkDown(this.cursors.left, 250))
            {
                IO.socket.emit("input", {action: 'move', direction: 'left'});
                // EIgenschaften des zu begehenden Tiles zuordnen
                var wall = this.walls.getTileAtWorldXY(this.player.x - 32, this.player.y, true);
                var breakable = this.obstracles.getTileAtWorldXY(this.player.x - 32, this.player.y, true);
                this.player.play('go-left');
                this.instance = checkInstance('left', breakable, wall);
                // Wenn Collide-Eigenschaften des zu begehenden Feldes Falsch sind darf gegangen werden
                if (!wall.properties.collide && !breakable.properties.collide)
                {
                    this.player.x -= 32;
                }


            }
            else if (this.input.keyboard.checkDown(this.cursors.right, 250))
            {
                IO.socket.emit("input", {action: 'move', direction: 'right'});
                var wall = this.walls.getTileAtWorldXY(this.player.x + 32, this.player.y, true);
                var breakable = this.obstracles.getTileAtWorldXY(this.player.x + 32, this.player.y, true);
                this.player.play('go-right');
                this.instance = checkInstance('right', breakable, wall);
                if (!wall.properties.collide && !breakable.properties.collide)
                {
                    this.player.x += 32;
                }

            }
            else if (this.input.keyboard.checkDown(this.cursors.up, 250))
            {
                IO.socket.emit("input", {action: 'move', direction: 'up'});
                var wall = this.walls.getTileAtWorldXY(this.player.x, this.player.y - 32, true);
                var breakable = this.obstracles.getTileAtWorldXY(this.player.x, this.player.y - 32, true);
                this.player.play('go-up');
                this.instance = checkInstance('up', breakable, wall);
                if (!wall.properties.collide && !breakable.properties.collide) {
                    this.player.y -= 32;
                }

            }
            else if (this.input.keyboard.checkDown(this.cursors.down, 250))
            {
                IO.socket.emit("input", {action: 'move', direction: 'down'});
                var wall = this.walls.getTileAtWorldXY(this.player.x, this.player.y + 32, true);
                var breakable = this.obstracles.getTileAtWorldXY(this.player.x, this.player.y + 32, true);
                this.player.play('go-down');
                this.instance = checkInstance('down', breakable, wall);
                if (!wall.properties.collide && !breakable.properties.collide)
                {
                    this.player.y += 32;
                }

            }
            if (this.player.body.velocity.x < 0.1)
            {
                this.player.anims.stop();

            }

            if (this.input.keyboard.checkDown(this.cursors.space))
            {
                IO.socket.emit("input", {action: 'bomb'});
                this.player.dropbomb(this.player.x, this.player.y, this.instance);

            }
        }


    }

    class Player extends Phaser.Physics.Arcade.Sprite{
        constructor(scene, x, y) {
            super(scene, x, y);
            this.scene = scene;

            this.name = 'Player';


            this.scene.add.existing(this);
            this.scene.physics.add.existing(this);

            this.setPosition(x,y);
            this.setTexture('player');
            this.setCollideWorldBounds(true);
            this.setScale(1);
            this.body.setBounce(0.8);

        }
        dropbomb(x,y, inst)
        {
            let bomb = new Bomb(this.scene, x,y, inst, this);
            bomb.setPosition(x,y);


        }
        diehard()
        {
            this.body.destroy();
            this.setVisible(false);
            //console.log('Game Over');


        }
    }
    class Bomb extends Phaser.Physics.Arcade.Sprite {

        constructor(scene, x, y, inst, player) {
            super(scene, x, y, inst, player);
            this.scene = scene;
            this.scene.physics.add.existing(this);
            this.scene.add.existing(this);

            this.setTexture('bomb').play('bomb-idle');
            this.setCollideWorldBounds(true);
            this.setScale(1);

            this.instance = inst;
            this.wall = inst.wall;
            this.obstracle = inst.obstracle;

            this.player = player;

            let duration = 2000;
            const explodeTimer = this.scene.time.delayedCall(duration, this.explode, [], this);


        }
        explode()
        {
            const explosion = [
                new Explosion(this.scene, this.player, this.obstracle),
                new Explosion(this.scene, this.player, this.obstracle),
                new Explosion(this.scene, this.player, this.obstracle),
                new Explosion(this.scene, this.player, this.obstracle)
            ];
            let step = 0;
            this.destroy();
            for(let i = 0; i < explosion.length; i++) {
                if(this.instance.name == 'left'  || this.instance.name == 'right')
                {
                    explosion[i].setPosition(this.x+step, this.y);
                    step += this.instance.position;
                }
                if(this.instance.name == 'up'  || this.instance.name == 'down')
                {
                    explosion[i].setPosition(this.x, this.y+step);
                    step += this.instance.position;
                }

            }

        }


    }
    class Explosion extends Phaser.Physics.Arcade.Sprite {
        constructor(scene, player, obs) {
            super(scene, player, obs);

            this.scene.physics.add.existing(this);
            this.scene.add.existing(this);

            this.setTexture('explosion').play('boom');
            this.setCollideWorldBounds(true);
            this.setScale(0.5);
            this.scene.cameras.main.shake(200);

            this.player = player;
            this.obstracle = obs;

            this.scene.physics.add.collider(this, this.player);
            this.scene.physics.add.collider(this, this.obstracle);

            this.scene.physics.overlap(
                this,
                this.player,
                this.player.diehard(),
                false,
                this.scene);

            this.scene.physics.overlap(
                this,
                this.obstracle,
                this.die(this.obstracle),
                false,
                this.scene);

            this.once('animationcomplete', ()=>  {
                this.destroy();
            })
        }
        die(object){

            this.obstracle.destroy();
        }

    }


    const config = {
        title: 'Explosion Guy',
        type: Phaser.AUTO,
        width: 544, //17 x 32
        height: 416, //13 x 32
        autoCenter: true,
        // Bildschirm ausfüllen
        scale: {
            mode: Phaser.Scale.FIT
        },
        scene: [Load,MainLevel],
        physics: {
            default:"arcade", arcade:{
                debug:true
            }
        }
    };


    const game = new Phaser.Game(config);

</script>
<script src="./js/app.js"></script>
</body>
</html>