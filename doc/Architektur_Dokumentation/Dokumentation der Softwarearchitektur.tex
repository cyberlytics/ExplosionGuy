\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage{ngerman}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Dokumentation der Softwarearchitektur des Projekts Explosion Guy}


% Authoren	
\author{
	\IEEEauthorblockN{Bösl Florian}
	\IEEEauthorblockA{
		\textit{f.boesl@oth-aw.de}\\
	}
	\and

	\IEEEauthorblockN{Kohl Helge}
	\IEEEauthorblockA{
		\textit{h.kohl@oth-aw.de}\\
	}
	\and

	\IEEEauthorblockN{Anastasia Chernysheva}
	\IEEEauthorblockA{
		\textit{a.chernysheva@oth-aw.de}\\
	}
	\and

	\IEEEauthorblockN{Korinth Patrice}
	\IEEEauthorblockA{
		\textit{p.korinth@oth-aw.de}\\
	}
	\and

	\IEEEauthorblockN{Porsch Philipp}
	\IEEEauthorblockA{
		\textit{p.porsch@oth-aw.de}\\
	}
}

\maketitle

\begin{abstract}
In diesem technischem Report wird die Softwarearchitektur des Projekts 
Explosion Guy vorgestellt. Das Projekt wurde im Rahmen der Vorlesung Big Data und Cloud-basiertes Computing implementiert. Ziel der Implementierung ist es, 
das allgemein bekannte Spiel "Bomberman" zu adaptieren und es mithilfe einer Cloud-Infrastruktur online spielbar zu machen.\\
\end{abstract}

\begin{IEEEkeywords}
 Webdesign, Matchmaking, Cloud Infrastructure
\end{IEEEkeywords}

\section{Introduction}
Bei der Applikation Explosion Guy geht es darum, das Spiel \glqq Bomberman\grqq{} zu adaptieren. Dabei werden dem Spieler mithilfe eines graphischen Web-Interfaces basierend auf Phaser anschauliche Informationen über den Verlauf des Spiels mitgeteilt. Das Interface dient auch dazu, die Eingaben des Spielers an das Backend weiterzureichen. Im Backend werden die Informationen aller Spieler verarbeitet und so ein online Spielerlebnis erzeugt.

\section{Architektur Allgemein}
\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{architecture.jpeg}
    \caption{Übersicht Gesamtsystem}
\end{figure*}
Als Architektur wird ein Ansatz verfolgt, der sich an einer Client-Server Kommunikation, ähnlich wie in anderen Onlinespielen, orientiert.
Dadurch wird eine abgeschlossene Logik von Front- und Backendkomponenten erreicht, die jeweils
von einem Subteam entwickelt wird. Diese Einheiten werden jeweils als isolierte Applikation gekapselt. Während das Backend als Anwendung innerhalb der Containervisualisierung Docker betrieben wird, wird das Frontend als allgemeine Webapplikation ausgeliefert. Durch eine zentrale Konfigurationsdatei des Containers kann dieser einfach zwischen den Teammitgliedern ausgetauscht und ausgeführt werden. Damit wird eine hohe Portabilität gewährleistet.
Die Kommunikation der Teilsysteme wird durch Websockets angeboten. Der Informationsaustausch über Websockets ermöglicht es, durch die identitätsbasierten Verbindungen die Kommunikation zwischen den Spielern und der zugehörigen Partei im Backend effizient zu gestalten.
Dadurch wird es möglich ein Echtzeiterlebnis mit zusätzlicher Überwachung aus dem Backend zu realisieren.
Durch die Einbettung der verschiedenen Bestandteile in einen Cloud-Service ist es jederzeit möglich, ein neues Spiel zu starten, oder einem vorhandenen Spiel beizutreten, da durch die nahezu unbegrenzten Ressourcen des Cloud-Services auf Anfrage neue Spielserver erstellt und verwaltet werden können.

\section{Frontend: Spielinterface}
% TODO:
Mithilfe des Web-Frameworks Phaser ist es möglich, ein graphisch ansprechendes Interface für das Spiel zu erstellen. Dabei werden nicht nur die Ausgangsinformationen in Form von Veränderungen des Spielfeldes für den Spieler bereitgestellt, sondern auch die Eingaben an das System vom Spieler erfasst. Diese Eingaben leitet das Frontend an das Backed weiter, von wo aus sie dann weiter verarbeitet werden können. Um ein möglichst flüssiges und ruckelfreies Spielerlebnis zu erzeugen, wurde das Frontend auch mit Teilen der Spiellogik ausgestattet. So können beispielsweise alle Bewegungen direkt nach Drücken der entsprechenden Eingabe ausgeführt werden ohne die Antwort des Backends abzuwarten, um Verzögerungen zu vermeiden. Sollte der Server nach Kontrolle einen ungültigen Spielzug feststellen, so wird der Zug zurückgesetzt. Dies erfüllt neben der Aufwertung des Gameplays auch eine kleine Anti-Cheat Rolle.
\\
\\
Die Funktionalität des Frontends umfasst folgende API-Zugriffe:
% TODO: Text ist noch als Vorlage da
\smallskip

\textbf{Filmsuche (/db/search-movies)}
\begin{itemize}
\item Beschreibung:
    Bei der Filmsuche werden in der Datenbank passende Filme gesucht.
\item Parameter:
\begin{itemize}
    \item Teiltitel
    \item Provider
\end{itemize}
\item Rückgabe:
    Liste mit Filmen und deren Metadaten
\end{itemize}

\smallskip

\textbf{Personensuche (/db/search-persons)}
\begin{itemize}
\item Beschreibung:
    Bei der Personensuche werden in der DBpedia Daten zu Filmmitwirkenden eines Filmes gesucht.
\item Parameter:
    \begin{itemize}
    \item Filmtitel
    \item Erscheinungsjahr
    \end{itemize}
\item Rückgabe:
    Liste der Filmmitwirkenden und dazugehörigen Metadaten
\end{itemize}

\smallskip

\textbf{Gemeinsamkeitensuche (/db/compare-movies)}
\begin{itemize}
\item Beschreibung:
    Bei der Gemeinsamkeitensuche werden gemeinsame Merkmale einzelner Filme gesucht.
\item Parameter:
    Liste mit Filmtiteln
\item Rückgabe:
    Liste der Gemeinsamkeiten der Filme
\end{itemize}

\smallskip

\textbf{Suche nach ähnlichen Filmen (/db/search-similar-movies)}
\begin{itemize}
\item Beschreibung:
    Bei der Suche nach ähnlichen Filmen werden Filme gesucht, die Gemeinsamkeiten mit den angebegeben Filmen aufweisen.
\item Parameter:
    \begin{itemize}
    \item Liste mit Filmtiteln
    \item Streamingdienstanbieter der zu vergleichenden Filme
    \end{itemize}
\item Rückgabe:
    Liste mit Filmen
\end{itemize}

\smallskip

\textbf{Suche nach IMDB Daten eines Filmes (/imdb/search-imdbdata)}
\begin{itemize}
\item Beschreibung:
    Bei der Suche nach einem Film werden die Bewertungen und ein hinterlegtes Bild des Filmes in der IMDB gesucht.
\item Parameter:
    Titel des Filmes
\item Rückgabe:
    \begin{itemize}
    \item Liste mit Bewertungen des Filmes
    \item URL eines in der IMDB hinterlegten Bildes
    \end{itemize}
\end{itemize}

\smallskip

Die Verwaltung der Daten erfolgt mittels einer Virtuoso-Datenbank. Diese enthält Filmdaten der Streamingdienstanbieter
Netflix, Amazon-Prime, Disney+ und Hulu, welche aus Kaggle bezogen wurden.
Die Datensätze enthalten Filmtitel der jeweiligen Provider, sowie dessen Metainformationen wie 
Filmmitwirkende, Genre und Erscheinungsjahr. Mithilfe einer in Virtuoso angelegten View ist es möglich
mit SparQl-Statements auf die importierten Daten zu zugreifen.
\\
\\
Das Modul "Fetch SPARQL Endpoint" ermöglicht es innerhalb der Filmverwaltung eine Verbindung zwischen dem Node-Server
und der Virtuoso-Datenbank sowie der DBpedia aufzubauen. Anschließend können SPARQL-Statements abgesetzt und die Ergebnisse
asynchron Verarbeitet werden.
\\
\\
Die IMDB ist eine Datenbank zu Filmen, Fernsehserien, Videoproduktionen und Computerspielen sowie über Personen,
die daran mitgewirkt haben. Sie bietet eine API zum Zugriff auf diese Daten. Dafür wird ein API-Schlüssel benötigt, 
mit diesem sind täglich 100 Anfragen kostenfrei verfügbar. Nach überschreiten dieser Begrenzung sind keine weiteren Anfragen
an diesem Tag möglich, die Anfragenbegrenzung kann jedoch kostenpflichtig erhöht werden. 
\\
\\
Um die vorgesehene Funktionalität gewährleisten zu können, wurden mithilfe von Jest, einem JavaScript Testframework, 
Unit- und Integrationstests entworfen. Dadurch kann die interne Integrität, sowie die Anbindung an externe Systeme,
sichergestellt werden. Die Tests wurden dabei mit dem Arrange-Act-Assert-Pattern entworfen. Dieses soll eine 
übersichtliche Struktur und Einheitlichkeit garantieren.

\section{Backend: Spiellogik und Matchmaking}
Das Backend besteht aus drei Aufgabenpaketen. Einerseits hat es die Aufgabe, die Informationen aller Spieler entgegenzunehmen, diese zu verarbeiten und sie danach an die jeweils anderen Spieler weiterzuleiten. Dies erfolgt nach dem \glqq Authoritative servers and dumb clients\grqq -Prinzip bei dem der Server immer den tatsächlichen Spielstatus hält und diesen an die Clients weitergibt. Andererseits muss das Backend die Funktionalität des Matchmakings übernehmen. Dazu muss es den Spielern die Möglichkeit geben, eigene Spielräume zu erstellen oder vorhandenen Räumen beizutreten. Die dritte Aufgabe des Backends ist es die nötigen Dateien für das Frontend auszuliefern. Um diese Funktionen optimal abzudecken, wurde das Backend in drei Teilbereiche getrennt, welche im Folgenden ausführlich beleuchtet werden.

\subsection{Spiellogik}
Das Paket der Spiellogik bildet das erste wichtige Bestandteil des Backends. Mit Spiellogik werden alle Abläufe, die im Hintergrund zu erfüllen sind, bezeichnet. So beispielsweise die Positionsbestimmung der Spieler nach einer Eingabe oder das Zählen eines Timers der Bomben. Zur Realisierung der Spiellogik wird ein Server mithilfe von Node.js innerhalb eines Docker Containers aufgebaut. Der Server verwaltet die Logik mit verschiedenen Klassen:

\begin{itemize}
    \item \textbf{Spieler}
    Die Spielerklasse enthält alle nötigen Informationen eines 	Spielers. Darunter dessen ID zur eindeutigen 					Identifizierung, seine Position auf dem Spielfeld, die 			Anzahl seiner Bomben und den ob dieser aktuell noch am 			Leben ist.
    \smallskip
    \item \textbf{Bombe} 
    Die Bombenklasse enthält ähnlich wie die Spielerklasse die 	Information ob über die Position des Bombenobjekt ihrer 		Explosionsstärke. Mithilfe eines Timers löst diese nach 		ablaufen desselben ein Explosionsevent aus, wodurch das 		Spielfeld angestoßen wird, die Explosion zu verarbeiten.
    \smallskip
    \item \textbf{Playground}
    Die Playgroundklasse spiegelt das Spielfeld wieder. Sie 
    enthält ihre Größe sowie die Spieler und Bombenobjekte.
    Zusätzlich werden die Positionen von Wänden und 
    zerstörbaren Objekten gespeichert. Mithilfe der 
    Playgroundklasse werden die Spielereingaben auf die
   	umgesetzt und der Spielstatus aktualisiert. Bei der
   	Explosion einer Bombe wird zusätzlich die Kollision 
   	mit Objekten verarbeitet.
    \smallskip
    \item \textbf{Game}
    Die Gameklasse enthält die übergeordneten Funktionen für
    Spiellogik. Sie erstellt den Playground und ruft die 
    nötigen Daten für die Initialisierung des Frontends ab.
    Zusätzlich leitet diese die Spielereingaben an das
    Playgroundobjekt weiter.
    
\smallskip

\end{itemize}
Der Spielserver hört auf folgendes Websocket-Event von Clientseite:
\begin{itemize}
\item Event: \textbf{input}

\item Beschreibung:
    Bei jeder Eingabe auf der Clientseite wird dieses Event ausgelöst. Die Eingabe wird an den Spielserver gesendet und von diesem verarbeitet. Je nach Eingabe wird ein spezifisches Antwort-Event zur Aktualisierung der Clients ausgelöst.
    
\item Parameter \glqq action\grqq{} kann folgende Werte annehmen:
\begin{itemize}
    \item left
    \item right
    \item up
    \item down
    \item bomb
\end{itemize}
\end{itemize}

\smallskip

Der Spielserver löst auf Clientseite folgende Websocket-Events aus:
\begin{itemize}
\item Event: \textbf{newGameCreated}
\begin{itemize}
\item Beschreibung:
    Die Clients werden darüber informiert, dass ein neues Spiel gestartet wurde. Sie erhalten alle nötigen Informationen um das Spiel auf Clientseite zu initialisieren.
    
\item Parameter \glqq mWidth\grqq{}: Spielfeldbreite
\item Parameter \glqq mHeight\grqq{}: Spielfeldhöhe
\item Parameter \glqq player\grqq{}: ID, Name und Position jedes Spielers
\item Parameter \glqq layer1Data\grqq{}: Matrix des Spielfeldes mit unzerstörbaren Wänden
\item Parameter \glqq layer2Data\grqq{}: Matrix des Spielfeldes mit zerstörbaren Objekten
\end{itemize}

\item Event: \textbf{update}
\begin{itemize}
\item Beschreibung:
    Antwort auf das \glqq input\grqq-Event eines Clients. Die Clients werden über darüber informiert wie sich das Spielfeld durch den Input verändert hat.
    
\item Fall 1 Input war Bewegung:
\begin{itemize}
\item Parameter \glqq input\grqq{}: Enthält den zugehörigen Inputtyp
\item Parameter \glqq data\grqq{}: Enthält Array Spieler-IDs und deren Position
\end{itemize}

\item Fall 2 Input war Bombe:
\begin{itemize}
\item Parameter \glqq input\grqq{}: Enthält den zugehörigen Inputtyp
\item Parameter \glqq PlayerId\grqq{}: Enthält die ID des Spielers der eine Bombe gesetzt hat
\item Parameter \glqq BombCount\grqq{}: Enthält den aktualisierten Bombcount des Spielers
\item Parameter \glqq PosX\grqq{}: Enthält die X-Position der Bombe
\item Parameter \glqq PosY\grqq{}: Enthält die Y-Position der Bombe
\item Parameter \glqq BombStrength\grqq{}: Enthält die Explosionsstärke der Bombe
\end{itemize}
    
\end{itemize}

\item Event: \textbf{explode}
\begin{itemize}
\item Beschreibung:
    Die Clients werden darüber informiert, dass eine Bombe explodiert. Sie erhalten alle nötigen Informationen um das Spiel auf Clientseite zu aktualisieren.
    
\item Parameter \glqq bomb\grqq{}: Position und Stärke der explodierenden Bombe
\item Parameter \glqq hitPlayers\grqq{}: ID und isAlive Status der getroffenen Spieler
\item Parameter \glqq destroyedObstacles\grqq{}: Position der zerstörten Hindernisse
\item Parameter \glqq explosionPositions\grqq{}: 
Positionen der Felder die Explodieren
\end{itemize}

\item Event: \textbf{Refresh}
\begin{itemize}
\item Beschreibung:
    Die Clients werden darüber informiert, dass ein Spieler eine neue Bombe erhält.
    
\item Parameter \glqq Id\grqq{}: ID des Spielers dessen Bombenanzahl aktualisiert wird
\item Parameter \glqq BombCount\grqq{}: Anzahl der Bomben des Spielers
\end{itemize}

\end{itemize}
\smallskip

\subsection{Matchmaking}
Das zweite wichtige Paket für die Gesamtfunktion ist das Paket des Matchmakings. Darunter lassen sich alle Mechanismen zusammenfassen, die es den Spielern ermöglichen, einen Raum zu erstellen oder einem Raum beizutreten. Realisiert wird dies, indem ein zusätzlicher Matchmaking Server aufgesetzt wird. Dieser wird wie der Logikserver mit Node.js und Docker bereitgestellt. Die Spieler werden also bei Verbindungsaufbau zunächst mit dem Matchmakingserver verbunden. Dieser leitet sie dann entweder an einen neu erstellten Spielraum oder an einen bereits vorhandenen Raum weiter. Innerhalb eines Spielraumes übernimmt dann die Spiellogik die Verwaltung, indem sie die für sich relevanten Spieler mithilfe ihrer Socket-ID adressiert. Der Matchmakingserver kennt also alle aktuellen Spielräume mit ihren Spielerzahlen und kann bei Bedarf neue Spielräume erstellen. Wird die Anzahl dieser Räume irgendwann so groß, dass sie ein einzelner Server nicht mehr versorgen könnte, so wird ein neuer Server für die Spielräume in der Cloud-Infrastruktur hochgefahren und an den Matchmakingserver weitervermittelt.

\subsection{File Server}
Das letzte Packet ist ist die File-Server-Funktionalität des Backends. Um das Spielen über den Browser des Nutzers zu ermöglichen müssen die nötigen Dateien abrufbar sein. Hierfür wurde ein eigenständiger File-Server aufgesetzt der die abgefragten Dateien ausliefert. Während der Entwicklung liegen diese Dateien auf dem Dateisystem des Entwicklers, im Live-Betrieb sollen diese in einem Amazon S3-Bucket abgelegt werden.

\subsection{Testing}
Zum Testen der verschiedenen Klassen und Funktionen des Backends wurde mithilfe von Jest für jede Klasse ein Testfile angelegt. Darin enthalten sind mehrere Testfälle, die teilweise iterativ die einzelnen Komponenten des Systems prüfen. Die Verwendung von Jest ermöglicht zudem eine Coverage-Prüfung, mit der es möglich ist, die genauen Prozentwerte der Testabdeckung sowie nicht abgedeckte Zeilen zu ermitteln. Nach Korrekter Einrichtung der einzelnen Testfälle ist es dann möglich, durch einen einzelnen Befehl die Integrität des gesamten Programmcodes zu verifizieren.

\begin{itemize}
    \item \textbf{Snapshot-Tests:}
    Die Snapshot-Tests erzeugen eine HTML-Document in welches die zu testende Komponente gerendert wird.
    Anschließend wird die HTML-Datei mit einer Snapshot-Datei verglichen, um sicher zu stellen das die Komponente wie erwartet dargestellt wird.
    \item \textbf{Funktionstest:}
    Bei den Funktionstests wird für jede Komponente eine Instanz mit dem Enzyme-Adapter erstellt.
    Mit dieser Objektinstanz könne verschieden Funktionen der Klasse getestet werden und geprüft werden ob Felder des Objekts richtig gesetzt werden.
\end{itemize}



\begin{thebibliography}{0}
	\bibitem{axios}Axios [Online] \url{https://www.npmjs.com/package/axios} (visited on Jan. 7, 2022)
    \bibitem{microservices}Microservice-Frontend-Architekturen [Online] \url{https://www.sigs-datacom.de/uploads/tx_dmjournals/attermeyer_OTS_Microservices_Docker_16.pdf} (visited on Jan. 7, 2022)
    \bibitem{reactTest}React-Testing [Online] \url{https://testing-library.com/docs/react-testing-library/intro/} (visited on Jan. 7, 2022)
    \bibitem{enzyme}Enzyme [Online] \url{https://www.npmjs.com/package/enzyme} (visited on Jan. 7, 2022)  
\end{thebibliography}

\end{document}
